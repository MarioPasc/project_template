#!/usr/bin/env python3

import logging
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import networkx as nx
from typing import List, Dict, Optional
from upsetplot import UpSet
from matplotlib_venn import venn2
import igraph as ig
from matplotlib.lines import Line2D

import scienceplots

# Style
plt.style.use(["science", "ieee", "std-colors"])
plt.rcParams["font.size"] = 10
plt.rcParams.update({"figure.dpi": "300"})
plt.rcParams["axes.spines.top"] = False
plt.rcParams["axes.spines.right"] = False

import os

VERBOSE: bool = os.environ.get("VERBOSE", "0") == "1"


class FunctionalVisualization:
    """
    Class for generating visualizations related to functional analysis.

    Includes the following main functions:
    - prepare_data_for_visualization_from_df:
        Prepares the data for visualizations based on a DataFrame with functional analysis results.
        Converts column formats for calculations and generates dictionaries to plot gene-term relationships.

    - Dot Plot: Shows the significance and magnitude of enrichment.

    - Bar Plot: Highlights the most significant terms.

    - Cnetplot: Visualizes relationships between genes and enriched categories.

    - upset_plot:
        Generates an UpSet plot to analyze intersections and patterns among enriched terms and clusters.
        This type of plot is useful for identifying overlapping patterns between functional data sets.

    - venn_diagram:
        Generates a Venn diagram to compare two sets of enriched terms derived
        from different clustering or analysis methods.
    """

    @staticmethod
    def prepare_data_for_visualization_from_df(df: pd.DataFrame, logger: logging.Logger):
        """
        Prepares the data from the DataFrame generated by FunctionalAnalysis for visualization.

        :param df: DataFrame with the results of the functional analysis.

        :return:
            - Processed DataFrame with additional columns ['Observed', 'Total', 'Gene Ratio'] for dot_plot, bar_plot, and cnetplot.
            - Dictionary where keys are terms ('Term') and values are lists of genes ('Genes') for cnetplot.
        """
        try:
            # Convert Overlap to Gene Ratio (proportion)
            df[["Observed", "Total"]] = (
                df["Overlap"].str.split("/", expand=True).astype(int)
            )
            df["Gene Ratio"] = df["Observed"] / df["Total"]

            # Create a dictionary for cnetplot
            gene_sets = {
                row["Term"]: row["Genes"].split(", ") for _, row in df.iterrows()
            }

            return df, gene_sets

        except Exception as e:
            logger.error(f"Error in prepare_data_for_visualization_from_df: {e}")
            return None, None

    @staticmethod
    def dot_plot(df: pd.DataFrame, logger: logging.Logger, output_file: str = None):
        """
        Generates a Dot Plot based on enriched terms.

        :param df: DataFrame with columns ['Term', 'Adjusted P-value', 'Gene Ratio'].
        :param output_file: Path to save the plot (optional).
        """
        try:
            # Sort terms by significance (most significant first)
            df = df.sort_values("Adjusted P-value", ascending=True).head(20)

            # Create a dot plot
            plt.figure(figsize=(10, 8))
            scatter = sns.scatterplot(
                data=df,
                x="Gene Ratio",
                y="Term",
                size="Adjusted P-value",
                hue="Adjusted P-value",
                sizes=(300, 50),  # Increase the size range of points
                palette="coolwarm",  # Enhance color contrast
                legend="brief",
            )
            plt.title("Dot Plot - Análisis de Enriquecimiento")
            plt.xlabel("Gene Ratio")
            plt.ylabel("Term")
            # plt.gca().yaxis.set_tick_params(labelsize=10)  # Improve label size
            plt.tight_layout()

            # Save the plot to a file if a path is specified
            if output_file:
                plt.savefig(output_file, dpi=300)
                if VERBOSE:
                    print(f"Dot plot saved to {output_file}")
            plt.close()
        except Exception as e:
            logger.error(f"Error in dot_plot: {e}")

    @staticmethod
    def bar_plot(df: pd.DataFrame, logger: logging.Logger, output_file: str = None):
        """
        Generates a Bar Plot to highlight the most enriched terms.

        :param df: DataFrame with columns ['Term', 'Adjusted P-value'].
        :param output_file: Path to save the plot (optional).
        """
        try:
            # Sort terms by significance (most significant first)
            df = df.sort_values("Adjusted P-value", ascending=True).head(20)

            # Create the bar plot
            plt.figure(figsize=(12, 8))
            sns.barplot(
                data=df,
                x="Adjusted P-value",
                y="Term",
                hue="Term",  # Assign hue to the same y-axis to avoid warnings
                dodge=False,  # Avoid unnecessary bar separation
                errorbar=None,  # Replace ci=None with errorbar=None
                palette="Spectral",  # More visually appealing color palette
                legend=False,  # Do not show the auto-generated legend by hue
            )
            plt.xscale("log")  # Logarithmic scale to emphasize differences
            plt.title(
                "Bar Plot - Análisis de Enriquecimiento", fontsize=16, fontweight="bold"
            )  # Styled title
            plt.xlabel(
                "Adjusted P-value (log scale)", fontsize=14
            )  # Improved X-axis label
            plt.ylabel("Term", fontsize=14)  # Improved Y-axis label
            plt.xticks(fontsize=12)  # Adjust font size for X-axis labels
            plt.yticks(fontsize=12)  # Adjust font size for Y-axis labels
            plt.grid(
                axis="x", linestyle="--", alpha=0.7
            )  # Add reference lines

            # Save the plot to a file if a path is specified
            if output_file:
                plt.savefig(output_file, dpi=300, bbox_inches="tight")
                if VERBOSE:
                    print(f"Bar plot saved to {output_file}")
            plt.close()
        except Exception as e:
            logger.error(f"Error in bar_plot: {e}")

    @staticmethod
    def cnet_plot_igraph(
        df: pd.DataFrame, logger: logging.Logger, gene_sets: Dict[str, List[str]], output_file: str = None
    ):
        """
        Generates a network plot (Cnetplot) showing the relationships between genes and enriched terms using igraph.

        :param df: DataFrame with columns ['Term', 'Genes'].
        :param gene_sets: Dictionary where keys are enriched terms and values are lists of genes.
        :param output_file: Path to save the plot (optional).
        """
        try:
            # Initialize an iGraph object
            graph = ig.Graph()

            # Add nodes for terms and genes, avoiding duplicates
            term_nodes = [
                {"name": term, "type": "term", "size": 20} for term in gene_sets.keys()
            ]
            gene_nodes = [
                {
                    "name": gene.replace("[", "").replace("]", "").replace('"', ""),
                    "type": "gene",
                    "size": 10,
                }
                for genes in gene_sets.values()
                for gene in genes
            ]

            # Combine nodes and remove duplicates by "name"
            all_nodes = {node["name"]: node for node in term_nodes + gene_nodes}
            graph.add_vertices([node["name"] for node in all_nodes.values()])

            # Add edges between terms and genes
            edges = []
            for term, genes in gene_sets.items():
                for gene in genes:
                    cleaned_gene = (
                        gene.replace("[", "").replace("]", "").replace('"', "")
                    )
                    edges.append((term, cleaned_gene))
            graph.add_edges(edges)

            # Set node attributes (size and type)
            graph.vs["size"] = [all_nodes[v["name"]]["size"] for v in graph.vs]
            graph.vs["type"] = [all_nodes[v["name"]]["type"] for v in graph.vs]

            # Define color mapping: terms -> blue, genes -> red
            graph.vs["color"] = [
                "skyblue" if v["type"] == "term" else "salmon" for v in graph.vs
            ]

            # Modify term labels: name in two rows (split by '\n')
            graph.vs["label"] = [
                v["name"].replace("(", "\n(") if v["type"] == "term" else v["name"]
                for v in graph.vs
            ]

            # Generate a layout
            layout = graph.layout("fruchterman_reingold")

            graph.vs["frame_color"] = graph.vs["color"]

            # Plot the graph
            plt.figure(figsize=(12, 10))
            ig.plot(
                graph,
                target=plt.gca(),
                layout=layout,
                vertex_size=graph.vs["size"],
                vertex_color=graph.vs["color"],
                vertex_label=graph.vs["label"],
                vertex_label_size=8,
                vertex_label_dist=2,
                edge_width=0.5,
                edge_color="gray",
                frame_color=graph.vs["frame_color"],
            )

            # Add a legend
            legend_elements = [
                Line2D(
                    [0],
                    [0],
                    marker="o",
                    color="w",
                    markerfacecolor="skyblue",
                    markersize=10,
                    label="Terms",
                ),
                Line2D(
                    [0],
                    [0],
                    marker="o",
                    color="w",
                    markerfacecolor="salmon",
                    markersize=10,
                    label="Genes",
                ),
            ]
            plt.legend(
                handles=legend_elements, loc="upper left", fontsize=10, frameon=True
            )

            # Add title
            plt.title("Cnetplot - Relaciones Gen-Término", fontsize=16)
            plt.tight_layout()

            # Save the output
            if output_file:
                plt.savefig(output_file, dpi=300)
                if VERBOSE:
                    print(f"Cnet plot saved to {output_file}")
            plt.close()
        except Exception as e:
            logger.error(f"Error in cnet_plot: {e}")

    @staticmethod
    def upset_plot(df: pd.DataFrame, logger: logging.Logger, output_file: Optional[str] = None):
        """
        Generates an UpSet plot showing intersections between GO terms and clusters.

        This plot is useful for analyzing the distribution of terms across multiple clusters,
        identifying overlaps or specific patterns.

        :param df:
            DataFrame containing the data to generate the plot. It must include the following columns:
                - 'Term': Name of the analyzed GO terms.
                - 'Cluster': Identifier of the cluster each term belongs to.
        :param output_file:
            Optional path to save the generated plot as a PDF file. If not provided,
            the plot will be displayed on the screen.

        :return:
            None. The function either displays or saves the generated plot.
        """
        try:
            # Verify that the required columns are present
            if not {"Term", "Cluster"}.issubset(df.columns):
                logger.error("The DataFrame must contain the columns 'Term' and 'Cluster'.")
                raise

            # Select only the required columns
            filtered_data = df[["Term", "Cluster"]]

            # Group by 'Cluster' and 'Term', count occurrences, and reshape into a binary matrix
            binary_data = (
                filtered_data.groupby(["Cluster", "Term"])
                .size()  # Count occurrences of each (Cluster, Term) pair
                .unstack(
                    fill_value=0
                )  # Expand 'Term' into columns, fill missing values with 0
                .astype(bool)  # Convert counts to boolean values
            )

            # Reset the index to convert clusters into a column
            binary_data = binary_data.reset_index()

            # Rename the cluster index column as 'count'
            # This is necessary because UpSet uses 'count' as a subset size marker
            binary_data = binary_data.rename(columns={"Cluster": "count"})

            # Select columns other than 'count' to set as the index
            index_columns = [col for col in binary_data.columns if col != "count"]
            binary_data = binary_data.set_index(index_columns)

            # Create the UpSet plot
            upset_plot = UpSet(
                binary_data,
                subset_size="count",  # Specify that subset sizes are based on the 'count' column
                show_counts=True,  # Display counts on the plot's bars
            )

            # Generate the plot
            upset_plot.plot()

            # Add a descriptive title to the plot
            plt.suptitle("UpSet Plot de Términos GO y Clusters")

            # Save the plot if a file path is provided
            if output_file:
                plt.savefig(output_file, dpi=300)
                if VERBOSE:
                    print(f"UpSet plot saved to {output_file}")

        except Exception as e:
            logger.error(f"Error in upset_plot: {e}")

    @staticmethod
    def venn_diagram(
        file_modularity: str, file_enrichment: str, logger: logging.Logger, output_file: Optional[str] = None
    ):
        """
        Generates a Venn diagram comparing GO terms between two optimization results of the same algorithm.
        Specifically, it compares Leiden clustering results for Maximum Modularity and Maximum Functional Enrichment Score.

        :param file_modularity: Path to the first CSV file containing a 'Term' column (Maximum Modularity results).
        :param file_enrichment: Path to the second CSV file containing a 'Term' column (Maximum Enrichment Score results).
        :param output_file: Optional path to save the generated diagram as an image file (PNG format).
        """
        try:
            # Read CSV files
            data_leiden_max_modularity = pd.read_csv(file_modularity)
            data_leiden_max_enrichment = pd.read_csv(file_enrichment)

            # Validate the presence of 'Term' column
            if (
                "Term" not in data_leiden_max_modularity.columns
                or "Term" not in data_leiden_max_enrichment.columns
            ):
                logger.error("Both input files must contain a 'Term' column.")
                raise

            # Extract unique terms from both files
            terms_modularity = set(data_leiden_max_modularity["Term"].dropna())
            terms_enrichment = set(data_leiden_max_enrichment["Term"].dropna())

            # Create the Venn diagram
            venn = venn2(
                [terms_modularity, terms_enrichment],
                (
                    f"Leiden (Máxima Modularidad)\nTotal: {len(terms_modularity)}",
                    f"Leiden (Máximo Puntuaje de Enrequecimiento Funcional)\nTotal: {len(terms_enrichment)}",
                ),
            )

            # Add a descriptive title
            plt.title(
                "Comparación de términos funcionales entre las soluciones \n"
                "con el algoritmo de Leiden (Max Modularidad vs Max Puntuaje de Enrequecimiento Funcional)"
            )

            # Save the diagram or display it
            if output_file:
                plt.savefig(output_file, dpi=300)
                if VERBOSE:
                    print(f"Venn diagram saved to {output_file}")

        except Exception as e:
            logger.error(f"Error in venn_diagram: {e}")
